An error occurred while executing the following cell:
------------------
# Robust Bayesian Binary logistic regression in 1d for iris flowers

# Code is based on
# https://github.com/aloctavodia/BAP/blob/master/code/Chp4/04_Generalizing_linear_models.ipynb


try:
    import pymc3 as pm
except:
    %pip install pymc3
    import pymc3 as pm
import numpy as np

try:
    import pandas as pd
except:
    %pip install pandas
    import pandas as pd
try:
    import theano.tensor as tt
except:
    %pip install theano
    import theano.tensor as tt
# import seaborn as sns
import scipy.stats as stats
from scipy.special import expit as logistic
import matplotlib.pyplot as plt

try:
    import arviz as az
except:
    %pip install arviz
    import arviz as az
try:
    from sklearn.datasets import load_iris
except:
    %pip install scikit-learn
    from sklearn.datasets import load_iris
import probml_utils as pml

iris = load_iris()
X = iris.data
y = iris.target

# Convert to pandas dataframe
df_iris = pd.DataFrame(data=iris.data, columns=["sepal_length", "sepal_width", "petal_length", "petal_width"])
df_iris["species"] = pd.Series(iris.target_names[y], dtype="category")


df = df_iris.query("species == ('setosa', 'versicolor')")
y_0 = pd.Categorical(df["species"]).codes
x_n = "sepal_length"
x_0 = df[x_n].values

# Create outliers
x_outliers = np.array([4.2, 4.5, 4.0, 4.3, 4.2, 4.4])
y_outliers = np.ones_like(x_outliers, dtype=int)


Ninliers = len(x_0)
Noutliers = len(x_outliers)
N = Ninliers + Noutliers
inlier_ndx = np.arange(0, Ninliers)
outlier_ndx = np.arange(Ninliers, N)

y_0 = np.concatenate((y_0, y_outliers))
x_0 = np.concatenate((x_0, x_outliers))

xmean = np.mean(x_0)
x_c = x_0 - xmean


def plot_training_data():
    plt.figure()
    for c in [0, 1]:
        ndx_c = np.where(y_0 == c)[0]
        color = f"C{c}"
        sigma = 0.02  # for vertical jittering
        inliers = np.intersect1d(ndx_c, inlier_ndx)
        plt.scatter(x_c[inliers], np.random.normal(y_0[inliers], sigma), marker="o", color=color)
        outliers = np.intersect1d(ndx_c, outlier_ndx)
        plt.scatter(x_c[outliers], np.random.normal(y_0[outliers], sigma), marker="x", color=color)

    plt.xlabel(x_n)
    plt.ylabel("p(y=1)", rotation=0)
    # use original scale for xticks
    locs, _ = plt.xticks()
    plt.xticks(locs, np.round(locs + xmean, 1))
    plt.tight_layout()


def infer_nonrobust_model():
    with pm.Model() as model_0:
        α = pm.Normal("α", mu=0, sd=10)
        β = pm.Normal("β", mu=0, sd=10)

        μ = α + pm.math.dot(x_c, β)
        θ = pm.Deterministic("θ", pm.math.sigmoid(μ))
        bd = pm.Deterministic("bd", -α / β)  # decision boundary

        yl = pm.Bernoulli("yl", p=θ, observed=y_0)

        trace = pm.sample(1000, cores=1, chains=2)

    varnames = ["α", "β", "bd"]
    az.summary(trace, varnames)
    return trace


def infer_robust_model():
    with pm.Model() as model_0:
        α = pm.Normal("α", mu=0, sd=10)
        β = pm.Normal("β", mu=0, sd=10)

        μ = α + pm.math.dot(x_c, β)
        θ = pm.Deterministic("θ", pm.math.sigmoid(μ))
        bd = pm.Deterministic("bd", -α / β)  # decision boundary

        # yl = pm.Bernoulli('yl', p=θ, observed=y_0)
        π = pm.Beta("π", 1.0, 1.0)  # probability of contamination
        p = π * 0.5 + (1 - π) * θ  # true prob or 0.5
        yl = pm.Bernoulli("yl", p=p, observed=y_0)

        trace = pm.sample(1000, cores=1, chains=2)

    varnames = ["α", "β", "bd", "π"]
    az.summary(trace, varnames)
    return trace


def make_plot(trace):
    plot_training_data()
    # plot logistic curve
    theta = trace["θ"].mean(axis=0)
    idx = np.argsort(x_c)
    plt.plot(x_c[idx], theta[idx], color="C2", lw=3)
    az.plot_hdi(x_c, trace["θ"], color="C2")

    # plot decision boundary
    plt.vlines(trace["bd"].mean(), 0, 1, color="k")
    bd_hpd = az.hdi(trace["bd"])
    plt.fill_betweenx([0, 1], bd_hpd[0], bd_hpd[1], color="k", alpha=0.5)


trace = infer_robust_model()
make_plot(trace)
pml.savefig("logreg_iris_bayes_robust_1d.pdf", dpi=300)

trace = infer_nonrobust_model()
make_plot(trace)
pml.savefig("logreg_iris_bayes_nonrobust_1d.pdf", dpi=300)

plt.show()
------------------

---------------------------------------------------------------------------
ModuleNotFoundError                       Traceback (most recent call last)
Input In [1], in <cell line: 7>()
      7 try:
----> 8     import pymc3 as pm
      9 except:

ModuleNotFoundError: No module named 'pymc3'

During handling of the above exception, another exception occurred:

ContextualVersionConflict                 Traceback (most recent call last)
Input In [1], in <cell line: 7>()
      9 except:
     10     get_ipython().run_line_magic('pip', 'install pymc3')
---> 11     import pymc3 as pm
     12 import numpy as np
     14 try:

File /usr/local/lib/python3.9/dist-packages/pymc3/__init__.py:115, in <module>
    112 __set_compiler_flags()
    113 _hotfix_theano_printing()
--> 115 from pymc3 import gp, ode, sampling
    116 from pymc3.backends import load_trace, save_trace
    117 from pymc3.backends.tracetab import *

File /usr/local/lib/python3.9/dist-packages/pymc3/gp/__init__.py:16, in <module>
      1 #   Copyright 2020 The PyMC Developers
      2 #
      3 #   Licensed under the Apache License, Version 2.0 (the "License");
   (...)
     12 #   See the License for the specific language governing permissions and
     13 #   limitations under the License.
     15 from pymc3.gp import cov, mean, util
---> 16 from pymc3.gp.gp import TP, Latent, LatentKron, Marginal, MarginalKron, MarginalSparse

File /usr/local/lib/python3.9/dist-packages/pymc3/gp/gp.py:25, in <module>
     21 from theano.tensor.nlinalg import eigh
     23 import pymc3 as pm
---> 25 from pymc3.distributions import draw_values
     26 from pymc3.gp.cov import Constant, Covariance
     27 from pymc3.gp.mean import Zero

File /usr/local/lib/python3.9/dist-packages/pymc3/distributions/__init__.py:15, in <module>
      1 #   Copyright 2020 The PyMC Developers
      2 #
      3 #   Licensed under the Apache License, Version 2.0 (the "License");
   (...)
     12 #   See the License for the specific language governing permissions and
     13 #   limitations under the License.
---> 15 from pymc3.distributions import shape_utils, timeseries, transforms
     16 from pymc3.distributions.bart import BART
     17 from pymc3.distributions.bound import Bound

File /usr/local/lib/python3.9/dist-packages/pymc3/distributions/timeseries.py:21, in <module>
     18 from scipy import stats
     19 from theano import scan
---> 21 from pymc3.distributions import distribution, multivariate
     22 from pymc3.distributions.continuous import Flat, Normal, get_tau_sigma
     23 from pymc3.distributions.shape_utils import to_tuple

File /usr/local/lib/python3.9/dist-packages/pymc3/distributions/distribution.py:45, in <module>
     38 from theano import function
     40 from pymc3.distributions.shape_utils import (
     41     broadcast_dist_samples_shape,
     42     get_broadcastable_dist_samples,
     43     to_tuple,
     44 )
---> 45 from pymc3.model import (
     46     ContextMeta,
     47     FreeRV,
     48     Model,
     49     MultiObservedRV,
     50     ObservedRV,
     51     build_named_node_tree,
     52 )
     53 from pymc3.util import get_repr_for_variable, get_var_name, hash_key
     54 from pymc3.vartypes import string_types, theano_constant

File /usr/local/lib/python3.9/dist-packages/pymc3/model.py:38, in <module>
     34 from theano.tensor.var import TensorVariable
     36 import pymc3 as pm
---> 38 from pymc3.blocking import ArrayOrdering, DictToArrayBijection
     39 from pymc3.exceptions import ImputationWarning
     40 from pymc3.theanof import floatX, generator, gradient, hessian, inputvars

File /usr/local/lib/python3.9/dist-packages/pymc3/blocking.py:25, in <module>
     21 import copy
     23 import numpy as np
---> 25 from pymc3.util import get_var_name
     27 __all__ = ["ArrayOrdering", "DictToArrayBijection", "DictToVarBijection"]
     29 VarMap = collections.namedtuple("VarMap", "var, slc, shp, dtyp")

File /usr/local/lib/python3.9/dist-packages/pymc3/util.py:21, in <module>
     17 import warnings
     19 from typing import Dict, List, Tuple, Union
---> 21 import arviz
     22 import dill
     23 import numpy as np

File /usr/local/lib/python3.9/dist-packages/arviz/__init__.py:32, in <module>
     26         super()._log(level, msg, *args, **kwargs)
     29 _log = Logger("arviz")
---> 32 from .data import *
     33 from .plots import *
     34 from .plots.backends import *

File /usr/local/lib/python3.9/dist-packages/arviz/data/__init__.py:3, in <module>
      1 """Code for loading and manipulating data structures."""
      2 from .base import CoordSpec, DimSpec, dict_to_dataset, numpy_to_data_array
----> 3 from .converters import convert_to_dataset, convert_to_inference_data
      4 from .datasets import clear_data_home, list_datasets, load_arviz_data
      5 from .inference_data import InferenceData, concat

File /usr/local/lib/python3.9/dist-packages/arviz/data/converters.py:11, in <module>
      9 from .io_emcee import from_emcee
     10 from .io_numpyro import from_numpyro
---> 11 from .io_pymc3 import from_pymc3
     12 from .io_pyro import from_pyro
     13 from .io_pystan import from_pystan

File /usr/local/lib/python3.9/dist-packages/arviz/data/io_pymc3.py:9, in <module>
      6 __all__ = ["from_pymc3", "from_pymc3_predictions"]
      8 try:
----> 9     pymc3_version = pkg_resources.get_distribution("pymc3").version
     10     PYMC3_V4 = packaging.version.parse(pymc3_version) >= packaging.version.parse("4.0")
     11 except pkg_resources.DistributionNotFound:

File /usr/lib/python3/dist-packages/pkg_resources/__init__.py:471, in get_distribution(dist)
    469     dist = Requirement.parse(dist)
    470 if isinstance(dist, Requirement):
--> 471     dist = get_provider(dist)
    472 if not isinstance(dist, Distribution):
    473     raise TypeError("Expected string, Requirement, or Distribution", dist)

File /usr/lib/python3/dist-packages/pkg_resources/__init__.py:347, in get_provider(moduleOrReq)
    345 """Return an IResourceProvider for the named module or requirement"""
    346 if isinstance(moduleOrReq, Requirement):
--> 347     return working_set.find(moduleOrReq) or require(str(moduleOrReq))[0]
    348 try:
    349     module = sys.modules[moduleOrReq]

File /usr/lib/python3/dist-packages/pkg_resources/__init__.py:891, in WorkingSet.require(self, *requirements)
    882 def require(self, *requirements):
    883     """Ensure that distributions matching `requirements` are activated
    884 
    885     `requirements` must be a string or a (possibly-nested) sequence
   (...)
    889     included, even if they were already activated in this working set.
    890     """
--> 891     needed = self.resolve(parse_requirements(requirements))
    893     for dist in needed:
    894         self.add(dist)

File /usr/lib/python3/dist-packages/pkg_resources/__init__.py:782, in WorkingSet.resolve(self, requirements, env, installer, replace_conflicting, extras)
    779 if dist not in req:
    780     # Oops, the "best" so far conflicts with a dependency
    781     dependent_req = required_by[req]
--> 782     raise VersionConflict(dist, req).with_context(dependent_req)
    784 # push the new requirements onto the stack
    785 new_requirements = dist.requires(req.extras)[::-1]

ContextualVersionConflict: (numpy 1.22.3 (/usr/local/lib/python3.9/dist-packages), Requirement.parse('numpy<1.22.2,>=1.15.0'), {'pymc3'})
ContextualVersionConflict: (numpy 1.22.3 (/usr/local/lib/python3.9/dist-packages), Requirement.parse('numpy<1.22.2,>=1.15.0'), {'pymc3'})
